import * as path from 'path';
import * as fs from 'fs/promises';

export class CoverageHookGenerator {
  private coverageHookPath?: string;

  public async createHookFile(): Promise<string> {
    const hookContent = this.generateHookContent();
    await this.writeHookFile(hookContent);
    return this.coverageHookPath!;
  }

  public async cleanup(): Promise<void> {
    if (this.coverageHookPath) {
      try {
        await fs.unlink(this.coverageHookPath);
      } catch {
        // Ignore errors during cleanup
      }
    }
  }

  public generateHookContent(): string {
    return `
// Stryker Bun Coverage Hook
// This file is automatically generated and injected to collect coverage data

${this.getInitializationCode()}
${this.getMutantTrackingCode()}
${this.getTestWrapperCode()}
`;
  }

  public getInitializationCode(): string {
    return `console.log('[COVERAGE HOOK] Loading coverage hook...');
if (typeof globalThis.__stryker__ === 'undefined') { globalThis.__stryker__ = {}; }
console.log('[COVERAGE HOOK] __stryker__ object:', globalThis.__stryker__);`;
  }

  public getTestWrapperCode(): string {
    return `const originalTest = globalThis.test || globalThis.it;
if (originalTest) {
  const wrappedTest = function(name, fn) {
    return originalTest(name, async function(...args) {
      const testId = name;
      // Set currentTestId for Stryker's instrumentation
      globalThis.__stryker__.currentTestId = testId;
      
      // Ensure mutantCoverage structure exists
      if (!globalThis.__stryker__.mutantCoverage) {
        globalThis.__stryker__.mutantCoverage = { static: {}, perTest: {} };
      }
      if (!globalThis.__stryker__.mutantCoverage.perTest[testId]) {
        globalThis.__stryker__.mutantCoverage.perTest[testId] = {};
      }
      
      try {
        const result = await fn.apply(this, args);
        return result;
      } finally {
        // Clear currentTestId after test completes
        globalThis.__stryker__.currentTestId = null;
      }
    });
  };
  Object.setPrototypeOf(wrappedTest, originalTest);
  Object.getOwnPropertyNames(originalTest).forEach(prop => {
    if (prop !== 'length' && prop !== 'name' && prop !== 'prototype') {
      wrappedTest[prop] = originalTest[prop];
    }
  });
  globalThis.test = wrappedTest;
  if (globalThis.it) globalThis.it = wrappedTest;
}`;
  }

  public getMutantTrackingCode(): string {
    return `// Hook is loaded - Stryker's instrumentation will handle coverage tracking
// The test wrapper above sets currentTestId which is all Stryker needs`;
  }

  private async writeHookFile(content: string): Promise<void> {
    const tempDir = path.join(process.cwd(), '.stryker-tmp');
    await fs.mkdir(tempDir, { recursive: true });
    this.coverageHookPath = path.join(tempDir, 'coverage-hook.js');
    await fs.writeFile(this.coverageHookPath, content, 'utf-8');
  }
}