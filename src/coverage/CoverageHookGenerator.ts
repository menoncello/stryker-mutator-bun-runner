import * as path from 'path';
import * as fs from 'fs/promises';

/**
 * Generates coverage hook files for Bun test instrumentation.
 * Creates JavaScript hooks that wrap test functions to track coverage.
 */
export class CoverageHookGenerator {
  private coverageHookPath?: string;

  /**
   * Creates a coverage hook file that will be preloaded by Bun.
   * @returns Promise that resolves to the path of the created hook file
   */
  public async createHookFile(): Promise<string> {
    const hookContent = this.generateHookContent();
    await this.writeHookFile(hookContent);
    return this.coverageHookPath!;
  }

  /**
   * Cleans up the generated coverage hook file.
   * Silently ignores errors if the file doesn't exist.
   */
  public async cleanup(): Promise<void> {
    if (this.coverageHookPath) {
      try {
        await fs.unlink(this.coverageHookPath);
      } catch {
        // Ignore errors during cleanup
      }
    }
  }

  /**
   * Generates the complete JavaScript content for the coverage hook.
   * @returns JavaScript code that sets up coverage tracking
   */
  public generateHookContent(): string {
    return `
// Stryker Bun Coverage Hook
// This file is automatically generated and injected to collect coverage data

${this.getInitializationCode()}
${this.getMutantTrackingCode()}
${this.getTestWrapperCode()}
`;
  }

  /**
   * Generates initialization code that sets up the global Stryker object.
   * @returns JavaScript code for initializing coverage tracking
   */
  public getInitializationCode(): string {
    return `console.log('[COVERAGE HOOK] Loading coverage hook...');
if (typeof globalThis.__stryker__ === 'undefined') { globalThis.__stryker__ = {}; }
console.log('[COVERAGE HOOK] __stryker__ object:', globalThis.__stryker__);`;
  }

  /**
   * Generates code that wraps test functions to track coverage per test.
   * @returns JavaScript code that wraps global test/it functions
   */
  public getTestWrapperCode(): string {
    return `const originalTest = globalThis.test || globalThis.it;
if (originalTest) {
  const wrappedTest = function(name, fn) {
    return originalTest(name, async function(...args) {
      const testId = name;
      // Set currentTestId for Stryker's instrumentation
      globalThis.__stryker__.currentTestId = testId;
      
      // Ensure mutantCoverage structure exists
      if (!globalThis.__stryker__.mutantCoverage) {
        globalThis.__stryker__.mutantCoverage = { static: {}, perTest: {} };
      }
      if (!globalThis.__stryker__.mutantCoverage.perTest[testId]) {
        globalThis.__stryker__.mutantCoverage.perTest[testId] = {};
      }
      
      try {
        const result = await fn.apply(this, args);
        return result;
      } finally {
        // Clear currentTestId after test completes
        globalThis.__stryker__.currentTestId = null;
      }
    });
  };
  Object.setPrototypeOf(wrappedTest, originalTest);
  Object.getOwnPropertyNames(originalTest).forEach(prop => {
    if (prop !== 'length' && prop !== 'name' && prop !== 'prototype') {
      wrappedTest[prop] = originalTest[prop];
    }
  });
  globalThis.test = wrappedTest;
  if (globalThis.it) globalThis.it = wrappedTest;
}`;
  }

  /**
   * Generates code for mutant tracking integration.
   * @returns JavaScript code that enables mutant coverage tracking
   */
  public getMutantTrackingCode(): string {
    return `// Hook is loaded - Stryker's instrumentation will handle coverage tracking
// The test wrapper above sets currentTestId which is all Stryker needs`;
  }

  private async writeHookFile(content: string): Promise<void> {
    const tempDir = path.join(process.cwd(), '.stryker-tmp');
    await fs.mkdir(tempDir, { recursive: true });
    this.coverageHookPath = path.join(tempDir, 'coverage-hook.js');
    await fs.writeFile(this.coverageHookPath, content, 'utf-8');
  }
}
