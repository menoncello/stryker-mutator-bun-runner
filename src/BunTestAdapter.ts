import { Logger } from '@stryker-mutator/api/dist/src/logging';
import { execa } from 'execa';
import { BunTestRunnerOptions, BunRunOptions, BunTestResult } from './BunTestRunnerOptions';
import { BunResultParser } from './BunResultParser';
import { MutantCoverageCollector, CoverageResult } from './coverage';
import * as path from 'path';
import * as fs from 'fs/promises';

export class BunTestAdapter {
  private readonly log: Logger;
  private readonly options: BunTestRunnerOptions;
  private readonly parser: BunResultParser;
  private readonly coverageCollector: MutantCoverageCollector;
  private coverageHookPath?: string;

  constructor(logger: Logger, options: BunTestRunnerOptions) {
    this.log = logger;
    this.options = options;
    this.parser = new BunResultParser(logger);
    this.coverageCollector = new MutantCoverageCollector(logger);
  }

  public async init(): Promise<void> {
    await this.coverageCollector.init();
    
    // Create coverage hook file if coverage is enabled
    if (this.options.coverageAnalysis !== 'off') {
      await this.createCoverageHookFile();
    }
  }

  public async runTests(testFiles: string[], runOptions: BunRunOptions): Promise<BunTestResult> {
    const args = this.buildBunArgs(testFiles, runOptions);
    const env = this.buildEnvironment(runOptions);

    // Start coverage collection if enabled
    let coverageResult: CoverageResult | undefined;
    if (runOptions.coverage) {
      this.coverageCollector.startCoverage();
    }

    this.log.debug(`Running bun with args: ${args.join(' ')}`);
    this.log.debug(`Environment variables: ${JSON.stringify(env)}`);

    try {
      const { stdout, stderr } = await execa('bun', args, {
        env,
        timeout: runOptions.timeout,
        reject: false // Don't reject on non-zero exit code
      });

      if (stderr) {
        this.log.debug(`Bun stderr: ${stderr}`);
      }

      const result = this.parser.parse(stdout);

      // Stop coverage collection if it was started
      if (runOptions.coverage) {
        coverageResult = this.coverageCollector.stopCoverage();
        result.coverage = coverageResult;
      }

      return result;
    } catch (error: unknown) {
      // Make sure to stop coverage collection on error
      if (runOptions.coverage) {
        this.coverageCollector.stopCoverage();
      }

      const errorObj = error as { timedOut?: boolean; message?: string };
      if (errorObj.timedOut) {
        errorObj.timedOut = true;
        throw error;
      }

      this.log.error('Failed to run bun tests', error);
      const message = errorObj.message || 'Unknown error';
      throw new Error(`Failed to run bun tests: ${message}`);
    }
  }

  public async dispose(): Promise<void> {
    await this.coverageCollector.dispose();
    
    // Clean up coverage hook file
    if (this.coverageHookPath) {
      try {
        await fs.unlink(this.coverageHookPath);
      } catch (error) {
        this.log.debug('Failed to clean up coverage hook file', error);
      }
    }
  }

  public getCoverageCollector(): MutantCoverageCollector {
    return this.coverageCollector;
  }

  private async createCoverageHookFile(): Promise<void> {
    const hookContent = this.generateHookContent();
    await this.writeHookFile(hookContent);
    this.log.debug(`Created coverage hook file at ${this.coverageHookPath}`);
  }

  private generateHookContent(): string {
    return `
// Stryker Bun Coverage Hook
// This file is automatically generated and injected to collect coverage data

${this.getInitializationCode()}
${this.getTestWrapperCode()}
${this.getMutantTrackingCode()}
`;
  }

  private getInitializationCode(): string {
    return `if (typeof globalThis.__stryker__ === 'undefined') { globalThis.__stryker__ = {}; }`;
  }

  private getTestWrapperCode(): string {
    return `const originalTest = globalThis.test || globalThis.it;
if (originalTest) {
  const wrappedTest = function(name, fn) {
    return originalTest(name, async function(...args) {
      const testId = name;
      globalThis.__stryker__.currentTestId = testId;
      if (!globalThis.__stryker__.mutantCoverage) {
        globalThis.__stryker__.mutantCoverage = { perTest: {} };
      }
      if (!globalThis.__stryker__.mutantCoverage.perTest[testId]) {
        globalThis.__stryker__.mutantCoverage.perTest[testId] = new Set();
      }
      try {
        const result = await fn.apply(this, args);
        return result;
      } finally {
        globalThis.__stryker__.currentTestId = null;
      }
    });
  };
  Object.setPrototypeOf(wrappedTest, originalTest);
  Object.getOwnPropertyNames(originalTest).forEach(prop => {
    if (prop !== 'length' && prop !== 'name' && prop !== 'prototype') {
      wrappedTest[prop] = originalTest[prop];
    }
  });
  globalThis.test = wrappedTest;
  if (globalThis.it) globalThis.it = wrappedTest;
}`;
  }

  private getMutantTrackingCode(): string {
    return `globalThis.__stryker__.trackMutant = function(mutantId) {
  if (globalThis.__stryker__.currentTestId && globalThis.__stryker__.mutantCoverage) {
    const testId = globalThis.__stryker__.currentTestId;
    if (!globalThis.__stryker__.mutantCoverage.perTest[testId]) {
      globalThis.__stryker__.mutantCoverage.perTest[testId] = new Set();
    }
    globalThis.__stryker__.mutantCoverage.perTest[testId].add(mutantId);
  }
};`;
  }

  private async writeHookFile(content: string): Promise<void> {
    const tempDir = path.join(process.cwd(), '.stryker-tmp');
    await fs.mkdir(tempDir, { recursive: true });
    this.coverageHookPath = path.join(tempDir, 'coverage-hook.js');
    await fs.writeFile(this.coverageHookPath, content, 'utf-8');
  }

  private buildEnvironment(options: BunRunOptions): Record<string, string> {
    const env: Record<string, string> = { ...process.env, NODE_ENV: 'test', ...this.options.env, ...options.env };
    if (options.activeMutant !== undefined) { env.__STRYKER_ACTIVE_MUTANT__ = options.activeMutant.toString(); }
    env.BUN_TEST_QUIET = '1';
    return env;
  }

  private buildBunArgs(testFiles: string[], options: BunRunOptions): string[] {
    const args: string[] = [];
    
    this.addBaseCommand(args);
    this.addCoverageArgs(args, options);
    this.addTestFiles(args, testFiles);
    this.addTestOptions(args, options);
    this.addNodeArgs(args);
    
    return args;
  }

  private addBaseCommand(args: string[]): void {
    if (this.options.command) {
      const commandParts = this.options.command.split(' ');
      args.push(...commandParts);
    } else {
      args.push('test');
    }
  }

  private addCoverageArgs(args: string[], options: BunRunOptions): void {
    if (options.coverage && this.coverageHookPath) {
      args.push('--preload', this.coverageHookPath);
    }
  }

  private addTestFiles(args: string[], testFiles: string[]): void {
    if (testFiles.length > 0) {
      args.push(...testFiles);
    } else if (this.options.testFiles && !this.options.command) {
      args.push(...this.options.testFiles);
    }
  }

  private addTestOptions(args: string[], options: BunRunOptions): void {
    if (this.options.command) return;
    
    if (options.testNamePattern) {
      args.push('--test-name-pattern', options.testNamePattern);
    }
    
    if (options.timeout) {
      args.push('--timeout', options.timeout.toString());
    }
    
    if (options.bail) {
      args.push('--bail');
    }
  }

  private addNodeArgs(args: string[]): void {
    if (this.options.nodeArgs) {
      args.push(...this.options.nodeArgs);
    }
  }

}